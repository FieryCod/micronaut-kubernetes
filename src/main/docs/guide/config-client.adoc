The Configuration client will read Kubernetes' `ConfigMap` and `Secret` instances and make them available as `PropertySource`
instances in your application.

Then, in any bean you can read the configuration values from the `ConfigMap` or `Secret` using `@Value` or
https://docs.micronaut.io/latest/guide/index.html#config[any other way to read configuration values].

Configuration parsing happens in the bootstrap phase. Therefore, to enable distributed configuration clients, define the following
in `bootstrap.yml` (or `.properties`, `.json`, etc):

[source,yaml]
----
micronaut:
  config-client:
    enabled: true
----

## ConfigMaps

Supported formats for `ConfigMap` are:

* Java `.properties`.
* YAML.
* JSON.
* Literal values.

The configuration client by default will read all the ConfigMaps for the specified namespace (or `default` if namespace
is not specified). You can further filter which config map names are processed by defining
`kubernetes.client.config-maps.includes` or `kubernetes.client.config-maps.excludes`:

[source,yaml]
----
kubernetes:
  client:
    config-maps:
      includes:
        - my-config-map
        - other-config-map
----

Or:

[source,yaml]
----
kubernetes:
  client:
    config-maps:
      excludes: not-this-config-map
----

In addition to that, Kubernetes labels can be used to better match the config maps that should be available as property
sources:

[source,yaml]
----
kubernetes:
  client:
    config-maps:
      labels:
        - app: my-app
        - env: prod
----

Note that on the resulting config maps, you can still further filter them with includes/excludes properties.

### Watching for changes in ConfigMaps

By default, this configuration module will watch for ConfigMaps added/modified/deleted, and provided that the changes
match with the above filters, they will be propagated to the `Environment` and refresh it.

This means that those changes will be immediately available in your application without a restart.

### Examples

You can create a Kubernetes `ConfigMap` off an existing file with the following command:

`kubectl create configmap my-config --from-file=my-config.properties`

Or:

`kubectl create configmap my-config --from-file=my-config.yml`

Or:

`kubectl create configmap my-config --from-file=my-config.json`

You can also create a `ConfigMap` from literal values:

`kubectl create configmap my-config --from-literal=special.how=very --from-literal=special.type=charm`

## Secrets

Secrets read from the Kubernetes API will be base64-decoded and made available as `PropertySource` s, so that they can be
also read with `@Value`, `@ConfigurationProperties`, etc.

NOTE: Only `Opaque` secrets will be considered.

By default, secrets access is diabled. To enable them, set in `bootstrap.yml`:

[source,yaml]
----
kubernetes:
  client:
    secrets:
      enabled: true
----

The configuration client, by default, will read all the Secrets for the specified namespace (or `default` if the namespace
is not specified). You can further filter which config map names are processed by defining
`kubernetes.client.secrets.includes` or `kubernetes.client.secrets.excludes`:

[source,yaml]
----
kubernetes:
  client:
    secrets:
      enabled: true
      includes: this-secret
----

Or:

[source,yaml]
----
kubernetes:
  client:
    secrets:
      enabled: true
      excludes: not-this-secret
----

Similarly to ConfigMaps, labels can also be used to match the desired secrets:

[source,yaml]
----
kubernetes:
  client:
    secrets:
      labels:
        - app: my-app
        - env: prod
----